"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AutocompleteHandler=AutocompleteHandler;var _AutocompleteContext=require("../lib/structures/contexts/AutocompleteContext");var _CommandManager=require("../lib/managers/CommandManager");var _jsLogger=_interopRequireDefault(require("js-logger"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}async function AutocompleteHandler(interaction){const client=interaction.client;const command=_CommandManager.Commands.get(interaction.commandName);if(!command)return;let args=command.arguments;if(interaction.options.getSubcommandGroup(false))args=args.find(argument=>argument.name===interaction.options.getSubcommandGroup())?.options;if(interaction.options.getSubcommand(false))args=args.find(argument=>argument.name===interaction.options.getSubcommand())?.options;const focused=interaction.options.getFocused(true);const argument=args.find(argument=>argument.name===focused.name);if(!argument)return;const ctx=new _AutocompleteContext.AutocompleteContext(client,{interaction:interaction,channel:interaction.channel,createdAt:interaction.createdAt,createdTimestamp:interaction.createdTimestamp,guild:interaction.guild,guildId:interaction.guildId,user:interaction.user,member:interaction.member,memberPermissions:interaction.memberPermissions,command:command,argument:argument,value:focused.value,respond:interaction.respond.bind(interaction)});await Promise.resolve(argument.run(ctx)).catch(error=>{_jsLogger.default.error(typeof error.code!=="undefined"?error.code:"",error.message);if(error.stack)_jsLogger.default.trace(error.stack)}).then(()=>{_jsLogger.default.debug(`Successfully ran autocomplete (${argument.name} -> ${command.name}) for ${interaction.user.username}`)})}